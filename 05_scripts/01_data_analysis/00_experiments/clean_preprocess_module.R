# Data cleaning and preprocessing functions
# @status: experimental
# @version:
# @author: Claire Peterson
# @contact: cspeters@uab.edu


fix_missing <- function(x, na.value) {
x[x == na.value] <- NA
x
}

# TODO: Add description, param and returns for remove_na function
remove_na <- function(data) {
  #' Remove NA values
  # TODO: Add 
  #' @description 
  #' @param 
  if (is.data.frame(data)) {
    data <- na.omit(data)  # Remove rows containing NA in a data frame
  } else {
    # If the input is a vector, remove NA values
    data <- data[!is.na(data)]  # Remove NA values in a vector
  }
  return(data)
}


separate_sgrna_summary <- function(input) {
  #' Separate sgRNA_summary.txt file generated by MAGeCK.
  #' 
  #' @description The sgRNA summary file generated by MAGeCK contains 'control_count' and 'treatment_count' columns. 
  #'              Columns contain the sgRNA counts for each replicate which are separated with '/'. 
  #'              Designed for STMN2 screen sgRNA summary file. 
  #'                  The STMN2 screen was comprised of 3 paired replicates after sorting (high and low), thus totaling to 6 samples.
  #' @param input The path to the sgRNA summary .txt file or the loaded dataframe.              
  #' @returns A dataframe with 'control_count' and 'treatment_count' parsed into separate columns.
    
  # Check if input is a file path or dataframe
  if (is.character(input)) {
    # If input is a file path, read the file
    sgrna_summary <- read.delim(input)
  } else if (is.data.frame(input)) {
    # If input is already a dataframe, use it directly
    sgrna_summary <- input
  } else {
    stop("Input must be either a file path or a dataframe.")
  }
  
  # Split the control and treatment counts into individual replicates
  sgrna_summary$control_1 <- sgrna_summary$control_count %>%
    str_split_i("/", 1) %>%
    as.numeric()
  sgrna_summary$control_2 <- sgrna_summary$control_count %>%
    str_split_i("/", 2) %>%
    as.numeric()
  sgrna_summary$control_3 <- sgrna_summary$control_count %>%
    str_split_i("/", 3) %>%
    as.numeric()
  
  sgrna_summary$treatment_1 <- sgrna_summary$treatment_count %>%
    str_split_i("/", 1) %>%
    as.numeric()
  sgrna_summary$treatment_2 <- sgrna_summary$treatment_count %>%
    str_split_i("/", 2) %>%
    as.numeric()
  sgrna_summary$treatment_3 <- sgrna_summary$treatment_count %>%
    str_split_i("/", 3) %>%
    as.numeric()
  
  return(sgrna_summary)
}



calculate_avg_sd_cv_sgrna_summary <- function(df) {
  #' Calculate mean, standard deviation, and coefficient of variation from sgRNA_summary.txt file generated by MAGeCK.
  #' 
  #' @description Calculates the mean, standard deviation, and coefficient of variation by sgRNA ID from separated sgRNA summary files.
  #'              Intended for further data processing steps directly following the [separate_sgrna_summary(file_path)] function. 
  #' @seealso [separate_sgrna_summary(file_path)]
  #' @param df A dataframe. Dataframe must have one column for each replicate which contains sgRNA counts for that replicate sample. 
  #'            Counts for replicates must be separated into distinct columns per replicate. Function fails to work with raw sgRNA_summary.txt file generated by MAGeCK.
  #'            In other words, each replicate must have its own '_count' column.
  #' @returns A dataframe with the following additional columns: 
  #'          'control_sd', 'treatment_sd', 'pooled_sum_squares', 'cv_low', 'cv_high'
  # Calculate the averages for control and treatment
  df <- df %>%
    mutate(
      control_avg = (control_1 + control_2 + control_3) / 3,
      treatment_avg = (treatment_1 + treatment_2 + treatment_3) / 3
    )

  # Calculate the standard deviations for control and treatment
  control_sd <- df[c("control_1", "control_2", "control_3")] %>% apply(1, sd)
  df <- cbind(df, control_sd = control_sd)

  treatment_sd <- df[c("treatment_1", "treatment_2", "treatment_3")] %>% apply(1, sd)
  df <- cbind(df, treatment_sd = treatment_sd)

  df <- df %>% mutate(
    pooled_sum_squares = sqrt(control_sd^2 + treatment_sd^2) / (control_avg + treatment_avg),
    cv_low = (control_sd)^2 / (control_avg),
    cv_high = (treatment_sd)^2 / (treatment_avg)
  )

  return(df)
}



# Function to clean and process raw counts data
clean_and_process_counts_for_dge <- function(raw_counts, sgRNA_col = "sgRNA", gene_col = "Gene", exclude_cols = c("sgRNA", "Gene")) {
  
  # Step 1: Identify numeric columns only (excluding sgRNA and Gene)
  numeric_cols <- setdiff(names(raw_counts)[3:ncol(raw_counts)], exclude_cols)
  
  # Step 2: Convert only numeric columns to numeric (to avoid coercion of non-numeric columns)
  raw_counts[numeric_cols] <- lapply(raw_counts[numeric_cols], as.numeric)
  
  # Step 3: Remove NAs
  no_na_raw_counts <- raw_counts %>% drop_na()
  
  # Step 4: Count the number of zeros in each numeric column
  zero_count_per_column <- sapply(no_na_raw_counts[numeric_cols], function(x) sum(x == 0, na.rm = TRUE))
  
  # Print statement showing the total number of zeros per column
  message(glue("There are {sum(zero_count_per_column)} zeros in the dataset across numeric columns:"))
  print(zero_count_per_column)
  
  # Step 5: Remove rows where sgRNA or Gene column has zeros, and replace zeros in other columns with a small value
  clean_raw_counts <- no_na_raw_counts %>%
    dplyr::filter(.data[[sgRNA_col]] != 0) %>%
    dplyr::filter(.data[[gene_col]] != 0) %>%
    dplyr::mutate(across(-all_of(exclude_cols), ~replace(., . == 0, 0.0001)))
  
  # Step 6: Verify that all 0s and NAs were removed
  remaining_zeros <- sapply(clean_raw_counts[numeric_cols], function(x) sum(x == 0, na.rm = TRUE))
  message("Remaining zeros in each column after cleaning:")
  print(remaining_zeros)
  
  # Step 7: Convert DataFrame to Matrix (excluding sgRNA and Gene columns)
  count_matrix <- as.matrix(clean_raw_counts[, -match(exclude_cols, names(clean_raw_counts))])
  
  # Set the rownames of the matrix to the Gene column
  rownames(count_matrix) <- clean_raw_counts[[sgRNA_col]]
  
  # Create dge object
  dge <- DGEList(counts = count_matrix, group = group)
  
  # Create a new col to label replicate number and sample info 
  dge$samples$id <- c(1,2,3,4,5,6) # 1=low1,2=low2,3=low3,4=high1,5=high2,6=high3
  dge$samples$replicate = c(1,2,3,1,2,3) # high 1, low 1, high 2, low 2, high 3, low 3
  
  # Create new list to label sgRNA ID
  dge$genes <- data.frame(gene = clean_raw_counts[, 2])
  # Copy the count data 
  dge$genes <- as.data.frame(dge$genes)
  dge$genes$sgrna_id <- as.matrix(clean_raw_counts[,1])
  
  # Return the clean counts matrix
  return(list(count_matrix = count_matrix, clean_raw_counts = clean_raw_counts, dge = dge))
}




# Example usage:
# Assuming 'raw_counts' is your DataFrame with columns including sgRNA and Gene
# result <- clean_and_process_counts(raw_counts)
# clean_df <- result$clean_df
# count_matrix <- result$count_matrix


# Data visualization -------------------------------------------------------------------------------

#' Plots boxplots of all columns within a df. DF must only contain columns with numeric data.
#' 
#' @description Intended for quick and dirty sense of how data is distributed.
#' @param df A dataframe. Dataframe columns must only consist of numeric values.
#' @returns A single plot displaying boxplots for all numeric columns.
#' @examples 
# TODO: add examples for function
plot_all_boxplots <- function(df) {
  # Ensure the data frame is in the correct format
  if (!is.data.frame(df)) {
    stop("Input must be a data frame.")
  }
  
  # Convert the data frame to a long format
  df_long <- df %>%
    tidyr::pivot_longer(cols = everything(), names_to = "variable", values_to = "value")
  
  # Plot boxplots for all columns
  p <- ggplot(df_long, aes(x = variable, y = value)) +
    geom_boxplot() +
    labs(title = "Boxplots of All Columns",
         x = "Variable",
         y = "Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability
  
  # Print the plot
  print(p)
}