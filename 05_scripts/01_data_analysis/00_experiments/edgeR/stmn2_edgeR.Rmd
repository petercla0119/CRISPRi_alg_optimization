---
title: "stmn2_edgeR"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false 
    toc_depth: 6
    number_sections: false
    theme: lumen
    df_print: paged
execute:
  echo: false
  warning: false
editor_options: 
  markdown: 
    wrap: sentence
---

**Objective**: The goal of the notebook is to use edgeR on the STMN2 screen. Previous attempts to generate plots from the STMN2 gene file had noise plateaued. Reminder that the MAGeCK output data is on the Desktop, whereas scripts are located

# STMN2 Screen

```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)

rm(list = ls()) # Clear environment

# Install packages
library(edgeR)
library(dplyr)
library(tidyverse)
library(MASS)
library(ggrepel)
library(yaml)
library(glue)
source("~/CRISPRi_alg_optimization/05_scripts/01_data_analysis/00_experiments/clean_preprocess_module.R")

```

```{r Import Normalized Counts}
file_config <- yaml.load_file("~/CRISPRi_alg_optimization/stmn2_config.yml")

raw_dat_path <- file_config$data$raw_count_data
norm_dat_path <- file_config$data$norm_count_data

# Import the original raw count data (from JH) from the STMN2 screen from the dual-guide (v8) parser script
raw_counts <- read.delim(raw_dat_path, sep = "\t", header = TRUE)
norm_counts <- read.delim(norm_dat_path, sep = "\t", header = TRUE)
```

## Experiments

### Experiment 1: Try analysis after removing all zero and NA values

#### 1.1 Reading in the data

```{r Exp 1.1 Create DGEList Object}
# Exp 1.1 Create DGEList object for edgeR ---- 
## Include the group information when creating the DGEList object
# Create a factor variable to define the group/condition
group <- factor(c("Low", "Low", "Low", "High", "High", "High"))
group <- relevel(group, ref = "Low") # Set "Low" as the reference group

exp1_count_matrix <- clean_and_process_counts_for_dge(raw_counts)
exp1_clean_raw_counts <- exp1_count_matrix$clean_raw_counts
exp1_dge <- exp1_count_matrix$dge
exp1_count_matrix <- exp1_count_matrix$count_matrix
```

#### 1.2. Filtering and Normalization

```{r Exp 1.2.1-2. Filtering}
# Exp 1.2.1 Filtering 1 ----
# Genes are only retained if they are expressed at a minimum level
# The group factor or the experimental design matrix can also be given directly to the filterBy Expr function
filterbyexpr_keep <- filterByExpr(exp1_dge, group = group)
table(filterbyexpr_keep)
exp1_dge_filterbyexpr <- exp1_dge[filterbyexpr_keep, ,keep.lib.sizes=FALSE]
exp1_dge_filterbyexpr <- exp1_dge # Keep a copy of counts filtered by expression
exp1_dge_filterbyexpr_ct <- nrow(exp1_dge$counts)

# Exp 1.2.2. Filtering 2 ----
# Filter out sgRNAs with at least 0.5 counts per million in at least 3 samples. Used CPM since values are standardized for systematic differences in the amount of sequencing between samples cpm function accounts for library differences
filtermanual_keep <- rowSums(cpm(exp1_dge$counts)>20)>=2
table(filtermanual_keep)
exp1_dge <- exp1_dge[filtermanual_keep, ,keep.lib.sizes=FALSE] # This is the exp1_dge obj we will move forward with for subsequent analyses
exp1_dge_filtermanual <- exp1_dge # Keep a copy of the counts filtered by manual threshold values
exp1_dge_filtermanual_ct <- nrow(exp1_dge$counts)

# Compare the number of genes retained after manual vs default filtering
print(exp1_dge_filterbyexpr_ct - exp1_dge_filtermanual_ct) # exp1_dge_filterbyexpr is more permissive than exp1_dge_filtermanual
length(base::setdiff(row.names(exp1_dge_filterbyexpr$counts), row.names(exp1_dge_filtermanual$counts)))
dropped_genes <- base::setdiff(row.names(exp1_dge_filterbyexpr$counts), row.names(exp1_dge_filtermanual$counts))

# Ensure STMN2 and TDP genes were not dropped
"STMN2" %in% dropped_genes
"TARBP1" %in% dropped_genes
```

*From Analyzing data from pooled genetic sequencing screens using edgeR,* **Chapt 2** *Analysis of a small shRNA-seq screen*

```{r Exp 1.2.3 Plot Filtered sgRNAs}
# Exp 1.2a. Plot Filtered sgRNAs ----
# Set up drug treatment colors
cols <- as.numeric(exp1_dge$samples$group) + 2

# Plot number of hairpins that could be matched per sample and total for each hairpin across all samples
barplot(colSums(exp1_dge$counts), 
        las=1, # Make x-axis text label horizontal
        main="Counts per index", sub = "With CPM > 20 in at least 2 samples",
        col=cols, cedge.names=0.5, cedge.adgeis=0.8)
barplot(rowSums(exp1_dge$counts), las = 2, 
        main = "Counts per sgRNA", sub = "With CPM > 20 in at least 2 samples",
        cex.names = 0.5, cex.axis = 0.8)
```

```{r Exp 1.2.4. I Verify Retainment of Genes of Interest}
# I want to ensure TDP and STMN2 are kept for downstream analysis - if not, then useless ----
keep <- as.matrix(filtermanual_keep) # Convert keep obj (logical) to a matrix to verify genes of interest are retained
# For genes_removed
genes_removed <- data.frame(Gene = rownames(keep[which(keep == FALSE), , drop = FALSE]), 
                            Value = keep[keep == FALSE])
# For genes_keep
genes_keep <- data.frame(Gene = rownames(keep[which(keep == TRUE), , drop = FALSE]), 
                         Value = keep[keep == TRUE])
# Verify that TDP and STMN2 are retained
genes_keep[genes_keep$Gene %in% c("TARBP1", "STMN2"), ]
```

```{r Exp 1.2.5. Normalization}
# Plot library sizes before normalization
barplot(dge$samples$lib.size, main = "Library Sizes Before Normalization", ylab = "Library Size")

## Carry out normalization using TMM
dge <- calcNormFactors(dge, method = "TMM")

# View normalization factors
dge$samples

# Get normalized counts per million (CPM)
normalized_counts <- cpm(dge)

# Apply normalization and plot normalization factors
barplot(dge$samples$lib.size * dge$samples$norm.factors, main = "Library Sizes After Normalization", ylab = "Effective Library Size")

# base::summary(dge$samples)
```

#### 1.3. Data Exploration.

Dimension 1 separates the high group from the low group, while dimension 2 (*maybe*) corresponds to the replicate number.
The MDS plot (*maybe*) suggests that the samples were paired.
The samples in the **High** group appear more heterogeneous than the samples in the **Low** group.

```{r Exp 1.3. MDS plot}
plotMDS(dge, col = cols, main = "MDS Plot")
```

#### 1.4. Design Matrix - Block design

Compare the two conditions (high/low) adjusting for differences between replicates by fitting an additive model: Primarily interested in the differences between "treatments" (high/low) We will use the **blocked** design for the rest of the analysis

```{r Exp 1.4. Block Design}
group <- factor(dge$samples$group)
replicate <- factor(dge$samples$replicate)
block_design_mat <- model.matrix(~replicate + group)
print(block_design_mat)
```

#### 1.5. Dispersion estimation

Options are *common dispersion*, *trended dispersion*, and *tagwise dispersion*.
*common dispersion* best for small datasets with few replicates and does not account for differences based on expression level (ie assumes all genes have similar biological variability).
*trended dispersion* best for larger datasets and suspect that variability depends on gene expression levels (eg low gene expression has higher noise).
*tagwise dispersion* best for large datasets and builds on trended dispersion but also models individual gene variability (ie accounts for gene-specific variability).

*robust=true* argument: enables robust dispersion estimation, making the analysis less sensitive to outliers and genes with extreme variability.
Useful for datasets with potential outliers or high variability and improves the stability and reliability of the dispersion estimates.

```{r Exp 1.5.1 Dispersion estimation}
# dge <- estimateDisp(dge, block_design_mat, robust = TRUE, tagwise = TRUE)
# Estimate dispersion
exp1.dge <- estimateDisp(dge, block_design_mat)
```

The square root of the common dispersion gives the coefficient of variation of the biological variation.
Here, the **common dispersion** is **`r exp1.dge$common.dispersion`** and the biological CV is **`r sqrt(exp1.dge$common.dispersion)`**

In the BCV plot below:\
\* The red line represents the common dispersion estimate.
It assumes all genes have the same biological variability.\
\* The blue line represents the trended dispersion estimate.
It is the smoothed function of the relationship between the mean expression (log CPM) and the BCV.

**BCV Plot Observations**

-   High BCV at low expression levels: genes with lower expression levels (below log CPM=2) tend to have a higher BCV. Thereby, suggests that lowly expressed genes tend to have higher variability across replicates. Typical of as low counts are more prone to noise and stochastic variation.
-   Lower BCV at higher expression levels: genes with highly expressed genes tend to have a lower BCV. Thereby, suggests that high gene expression levels tend to have more stable expression, with less biological variability. Typical as higher counts tend to be more robust and less susceptible to random fluctuations.
-   Flater BCV at very high expression levels: The right side of the blue trend line indicates that highly expressed genes generally have low and stable variability.\

```{r Exp 1.5.2. Plot the dispersion estimates in a BCV plot}
plotBCV(exp1.dge, main = "STMN2 BCV Plot")
```

#### 1.6. Differential Expression Analysis

```{r Exp 1.6.2 QLT Differential expression analysis}
# Likelihood ratio test for low vs high differences and show the top genes
fit_ql <- glmQLFit(exp1.dge, block_design_mat)
```

```{r}
qlt <- glmQLFTest(fit_ql)
exp1_lrt_toptags <- topTags(qlt, n=Inf)
exp1_lrt_df <- as.data.frame(exp1_lrt_toptags$table)
```

```{r Exp 1.6.2.1 QLF QQ plot}
# Make qq-plot
gof(fit_ql, plot = TRUE, main = "QQ Plot of Residual Deviances of fit_ql")
plot(exp1_lrt_df$logFC, exp1_lrt_df$PValue)
```

```{r Exp 1.6.3 LRT Differential expression analysis}
# Likelihood ratio test for low vs high differences and show the top genes
fit_lr <- glmFit(exp1.dge, block_design_mat)
```

```{r}
lrt <- glmLRT(fit_lr)
lrt_top <- topTags(lrt, adjust.method = "BH", n = Inf)
# lrt_fdr_0.005 <- lrt_top$table[lrt_top$table$FDR < 0.005, ]
# lrt_fdr_0.005 %>% dplyr::filter(gene =="STMN2" | gene =="TARBP")
```

```{r Exp 1.6.3.1 LRT QQ plot}
# # Make qq-plot
gof(fit_lr, plot = TRUE, main = "QQ Plot of Residual Deviances of fit_lr")
# for (i in 1:6) {
#     plotMD(normalized_counts, column = i, 
#            main = "Mean-difference plot (MD-plot) by sample ")
#     abline(h = 0, col = "red", lty = 2, lwd = 2)
# }
# dev.off()
```

```{r mk toptags into csv}
# out <- topTags(lrt, n=Inf)
# write.csv(out, file = "STMN2_edgeR_LRT_topTags.csv")
```

All the top genes have consistent low vs high changes across replicates

```{r Exp 1.6.2 Adjust for baseline differences between replicates}
colnames(block_design_mat)
o <- order(lrt$table$PValue)
cpm(exp1.dge)[o[1:10],]
```

The total number of genes with a FDR \< 0.05 is **`r summary(decideTests(lrt))`**.\
The total number of genes with a logFC \< -1 is **`r sum(lrt$table$logFC < -3)`**.\
The total number of genes with a logFC \> 1 is **`r sum(lrt$table$logFC > 3)`**.

#### Volcano plot ----

```{r}
# Convert lrt_top object into dataframe
lrt_top_df <- as.data.frame(lrt_top$table)


npg <- c("#E64B35B2", "#4DBBD5B2", "#00A087B2", "#3C5488B2", "#F39B7FB2", "#8491B4B2", "#91D1C2B2", "#DC0000B2", "#7E6148B2")

negative <- lrt_top_df %>% 
  dplyr::filter(logFC < 0 & !grepl('negative_control', gene)) %>% 
  dplyr::arrange(PValue)
positive <- lrt_top_df %>% 
  dplyr::filter(logFC > 0 & !grepl('negative_control', gene)) %>% 
  dplyr::arrange(PValue)
ntc <- lrt_top_df %>% dplyr::filter(grepl('negative_control', gene))
both <- base::rbind(negative, positive, ntc) %>% 
  dplyr::mutate(
    qvalue = round(-log10(PValue), digits = 5),
    diffexpressed = ifelse(logFC > 0 & !grepl('negative_control', gene), "Upregulated", 
                           ifelse(logFC < 0 & !grepl('negative_control', gene), "Downregulated", 
                                  ifelse(grepl('negative_control', gene), "NTC", "Not significant"))))
# both_thresh <- 
#   both %>% dplyr::filter(FDR < 0.05)


# Create volcano plot ---------
# Create a new column in df to indicate the category of each point
both$category <- "Other genes"
both$category[both$gene %in% positive$gene] <- "Positive hits"
both$category[both$gene %in% negative$gene] <- "Negative hits"
both$category[both$gene %in% 'negative_control'] <- "Negative control"
# Top genes from "Low" group
low_top_genes <- negative[1:10,1]
high_top_genes <- positive[1:10,1]

# Original low/high genes from mageck
# low_top_genes <- c('GET4','MAP2K4','CLASRP','POU3F1','ECEL1','NOTCH1','ATF2','CHORDC1','CALM2','UBE3C')
# high_top_genes <- c('RANBP1','KIAA1919','FADS2','CCNC','TARDBP','STMN2','ZC3H13','LARP6','RBL2','PAPOLG')


# Create a new column "delabel" to de, that will contain the name of the top 30 differentially expressed genes (NA in case they are not)
both$delabel <- ifelse(both$gene %in% head(both[order(both$PValue), "gene"], 30), both$gene, NA)
both$diffexpressed <- "NO"
both$diffexpressed[both$logFC > 2 & both$PValue < 0.00001] <- "UP"
both$diffexpressed[both$logFC < -2 & both$PValue < 0.00001] <- "DOWN"


myvolcanoplot <- ggplot(data = both, aes(x = logFC, y = qvalue, col = diffexpressed, label = delabel, alpha =0.5)) +
  geom_vline(xintercept = c(-2, 2), col = "gray", linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.00001), col = "gray", linetype = 'dashed') +
  geom_point(size = 2) +
  geom_jitter(data = both %>% dplyr::filter(gene == "STMN2"), aes(x = logFC, y = qvalue), size = 1.5, alpha = 0.9, color = "black") +
  scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
                     labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
  labs(color = 'Severe', #legend_title,
       x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
  scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
  ggtitle('STMN2 Screen sgRNAs') + # Plot title
  geom_text_repel(max.overlaps = Inf) # To show all labels 
myvolcanoplot
```

#### 1.7 Gene Ontology Analysis

```{r Exp 1.7 Gene Ontology Analysis}
# TODO: Add gene annotation for pathway analysis
# go <- goana(lrt)
# topGO(go, n = 10)
```

#### 1.x. Session Info

```{r Exp 1.x Session info}
sessionInfo()
```

### Experiment 2: Try analysis with glmQLFit and glmLRT functions. Differs from the experiment above as this experiment uses glmQLFit followed by glmLRT functions for the analysis which resulted in TDP and STMN2 being listed as a top hit in analysis.

#### 2.1 Reading in the data

```{r}
# Exp 1.1 Create DGEList object for edgeR ----
## Convert the DataFrame to a Matrix
## Assuming df is your dataframe and the first column contains gene names
count_matrix <- as.matrix(clean_raw_counts[, -1:-2])  # Exclude the two columns with sgRNAs and gene names
rownames(count_matrix) <- clean_raw_counts[, 2]    # Set the gene names as rownames

## Include the group information when creating the DGEList object
# Create a factor variable to define the group/condition
group <- factor(c("Low", "Low", "Low", "High", "High", "High"))
group <- relevel(group, ref = "Low") # Set "Low" as the reference group

# Create dge object
dge <- DGEList(counts = count_matrix, group = group)

# Create a new col to label replicate number and sample info 
dge$samples$id <- c(1,2,3,4,5,6) # 1=low1,2=low2,3=low3,4=high1,5=high2,6=high3
dge$samples$replicate = factor(c("rep1", "rep2", "rep3", "rep1", "rep2", "rep3")) # high 1, low 1, high 2, low 2, high 3, low 3
dge$samples$replicate <- relevel(dge$samples$replicate, ref = "rep3")

# Create new list to label sgRNA ID
dge$genes <- data.frame(gene = clean_raw_counts[, 2])
# Copy the count data 
dge$genes <- as.data.frame(dge$genes)
dge$genes$sgrna_id <- as.matrix(clean_raw_counts[,1])
```

#### 2.2. Filtering and Normalization

```{r}
# Exp 1.2.1 Filtering 1 ----
# Genes are only retained if they are expressed at a minimum level
# The group factor or the experimental design matrix can also be given directly to the filterBy Expr function
# keep <- filterByExpr(dge, group = group)
# dge_exp2_filterbyexpr <- dge[keep, , keep.lib.sizes=FALSE]
# dge <- dge_exp2_filterbyexpr

# Exp 1.2.2. Filtering 2 ----
# Filter out sgRNAs with at least 0.5 counts per million in at least 3 samples. Used CPM since values are standardized for systematic differences in the amount of sequencing between samples
exp2_filtermanual_keep <- rowSums(cpm(dge$counts)>50)>=2
table(exp2_filtermanual_keep)
dge_exp2_filtermanual = dge[exp2_filtermanual_keep, ,keep.lib.sizes=FALSE]
dge <- dge_exp2_filtermanual
```

*From Analyzing data from pooled genetic sequencing screens using edgeR,* **Chapt 2** *Analysis of a small shRNA-seq screen*

```{r}
# Exp 1.2a. Plot Filtered sgRNAs ----
# Set up drug treatment colors
cols <- as.numeric(dge$samples$group) + 2
# cols_1b <- as.numeric(dge_1b$samples$group) + 2

# Plot number of hairpins that could be matched per sample and total for each hairpin across all samples
barplot(colSums(dge$counts), 
        las=1, # Make x-axis text label horizontal
        main="Counts per index", sub = "From filterByExpr",
        col=cols, cedge.names=0.5, cedge.adgeis=0.8)
barplot(rowSums(dge$counts), las = 2, 
        main = "Counts per sgRNA", sub = "From filterByExpr",
        cex.names = 0.5, cex.axis = 0.8)
```

```{r}
# I want to ensure TDP and STMN2 are kept for downstream analysis - if not, then useless ----
keep <- as.matrix(keep) # Convert keep obj (logical) to a matrix to verify genes of interest are retained
# For genes_removed
genes_removed <- data.frame(Gene = rownames(keep[which(keep == FALSE), , drop = FALSE]), 
                            Value = keep[keep == FALSE])
# For genes_keep
genes_keep <- data.frame(Gene = rownames(keep[which(keep == TRUE), , drop = FALSE]), 
                         Value = keep[keep == TRUE])
# Verify that TDP and STMN2 are retained
genes_keep[genes_keep$Gene %in% c("TARBP1", "STMN2"), ]
```

```{r}
# Exp 1b. Normalize ----
# Plot library sizes before normalization
barplot(dge$samples$lib.size, main = "Library Sizes Before Normalization", ylab = "Library Size")

## Carry out normalization using TMM
dge <- calcNormFactors(dge, method = "TMM")

# View normalization factors
dge$samples

# Get normalized counts per million (CPM)
normalized_counts <- cpm(dge)

base::summary(dge$samples)
```

#### 2.3. Data Exploration

Dimension 1 separates the high group from the low group, while dimension 2 (*maybe*) corresponds to the replicate number.
The MDS plot (*maybe*) suggests that the samples were paired.
The samples in the **High** group appear more heterogeneous than the samples in the **Low** group.

```{r}
plotMDS(dge, col = cols, main = "MDS Plot")
```

#### 2.4. Design Matrix - Block design

Compare the two conditions (high/low) adjusting for differences between replicates by fitting an additive model:\
Primarily interested in the differences between "treatments" (high/low).
*Differences between replicates are not of primary interest, nor are we interested in a "treatment" effect that occurs for one replicate as this is not reproducible.*

```{r, echo=TRUE}
group <- factor(dge$samples$group)
dge$samples$replicate = as.factor(dge$samples$replicate)
replicate <- factor(dge$samples$replicate)
block_design_mat <- model.matrix(~replicate + group)
```

#### 2.5. Dispersion estimation

```{r}
# Estimate dispersion
exp2_block_dge <- estimateDisp(dge, block_design_mat)
```

The square root of the common dispersion gives the coefficient of variation of the biological variation.
Here, the **common dispersion** is **`r exp2_block_dge$common.dispersion`** and the biological CV is **`r sqrt(exp2_block_dge$common.dispersion)`**

```{r}
plotBCV(exp2_block_dge, main = "STMN2 BCV Plot")
```

#### 2.6. Differential Expression Analysis

```{r}
# To detect genes that are differentially expressed between either group (high/low), adjusting for replicate differences
exp2_fit <- glmQLFit(exp2_block_dge, block_design_mat)
```

```{r}
exp2_lrt <- glmLRT(exp2_fit, coef=4)
exp2_lrt_toptags <- topTags(exp2_lrt, n=Inf)
head(exp2_lrt_toptags$table, n=10)
```

```{r}
# Make qq-plot
gof(exp2_fit, plot = TRUE, main = "QQ Plot of Residual Deviances of fit_ql")
```

All the top genes have consistent low vs high changes across replicates

```{r}
colnames(block_design_mat)
o <- order(exp2_lrt$table$PValue)
cpm(exp2_block_dge)[o[1:10],]
```

The total number of genes with a FDR \< 0.05 is **`r summary(decideTests(exp2_lrt))`**.
The total number of genes with a logFC \< -1 is **`r sum(exp2_lrt$table$logFC < -1)`**.
The total number of genes with a logFC \> 1 is **`r sum(exp2_lrt$table$logFC > 1)`**.
#### Volcano plot ----

```{r}
# Convert lrt_top object into dataframe
exp2_lrt_df <- as.data.frame(exp2_lrt_toptags$table)
exp2_lrt_df=exp2_lrt_df %>% dplyr::arrange(PValue)
# Shrink LFC values
# res <- glmTreat(fit, coef=2, lfc=log2(1.5))


npg <- c("#E64B35B2", "#4DBBD5B2", "#00A087B2", "#3C5488B2", "#F39B7FB2", "#8491B4B2", "#91D1C2B2", "#DC0000B2", "#7E6148B2")

negative <- exp2_lrt_df %>% 
  dplyr::filter(logFC < 0 & !grepl('negative_control', gene)) %>% 
  dplyr::arrange(PValue)
positive <- exp2_lrt_df %>% 
  dplyr::filter(logFC > 0 & !grepl('negative_control', gene)) %>% 
  dplyr::arrange(PValue)
ntc <- exp2_lrt_df %>% dplyr::filter(grepl('negative_control', gene))
exp2_lrt_df <- base::rbind(negative, positive, ntc) %>% 
  dplyr::mutate(
    qvalue = round(-log10(PValue), digits = 5))
# Create volcano plot ---------

# Original low/high genes from mageck
# low_top_genes <- c('GET4','MAP2K4','CLASRP','POU3F1','ECEL1','NOTCH1','ATF2','CHORDC1','CALM2','UBE3C')
# high_top_genes <- c('RANBP1','KIAA1919','FADS2','CCNC','TARDBP','STMN2','ZC3H13','LARP6','RBL2','PAPOLG')

# Create a new column "delabel" to de, that will contain the name of the top 30 differentially expressed genes (NA in case they are not)
exp2_lrt_df$delabel <- ifelse(exp2_lrt_df$gene %in% head(exp2_lrt_df[order(exp2_lrt_df$PValue), "gene"], 30), exp2_lrt_df$gene, NA)
exp2_lrt_df$diffexpressed <- "NO"
exp2_lrt_df$diffexpressed[exp2_lrt_df$logFC > 2 & exp2_lrt_df$PValue < 0.00001] <- "UP"
exp2_lrt_df$diffexpressed[exp2_lrt_df$logFC < -2 & exp2_lrt_df$PValue < 0.00001] <- "DOWN"


myvolcanoplot <- ggplot(data = exp2_lrt_df, aes(x = logFC, y = -log10(PValue), col = diffexpressed, label = delabel, alpha =0.5)) +
  geom_vline(xintercept = c(-2, 2), col = "gray", linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.00001), col = "gray", linetype = 'dashed') +
  geom_point(size = 2) +
  geom_jitter(data = exp2_lrt_df %>% dplyr::filter(gene == "STMN2" | gene == "TARBP"), aes(x = logFC, y = -log10(PValue)), size = 1.5, alpha = 0.9, color = "black") +
  scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
                     labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
  labs(color = 'Severe', #legend_title,
       x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
  scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
  ggtitle('STMN2 Screen sgRNAs') + # Plot title
  geom_text_repel(max.overlaps = Inf) # To show all labels 
myvolcanoplot

```

##### Run Diagnostics on Volcano Plot

```{r}
plot(exp1_lrt_df$logCPM, exp1_lrt_df$logFC, xlab="Average log CPM", ylab="log-fold-change", pch=16, cex=0.4)
abline(h=0, col="red")
title(main = "MA Plot of Exp 1")


plot(exp2_lrt_df$logCPM, exp2_lrt_df$logFC, xlab="Average log CPM", ylab="log-fold-change", pch=16, cex=0.4)
abline(h=0, col="red")
title(main = "MA Plot of Exp 2")

```

**LFC and logCPM values are identical across dry lab experiments, only pvalues and FDR differ with LRT**

```{r}
# CHECK: volcanoplot for exp 2 is parobolic... why?
# TODO: check summary plots of exp 1 and exp 2 for logFC and logCPM 

plot(exp1_lrt_df$logFC)
plot(exp2_lrt_df$logFC)

plot(exp1_lrt_df$logCPM)
plot(exp2_lrt_df$logCPM)
exp2_lrt_df = exp2_lrt_df %>% arrange(PValue)
plot(exp1_lrt_df$PValue)
plot(exp2_lrt_df$PValue)

summary(exp1_lrt_df)
summary(exp2_lrt_df)

plot(exp1_lrt_df$logCPM, exp1_lrt_df$logFC)
plot(exp2_lrt_df$logCPM, exp2_lrt_df$logFC)

```

```{r}
# TODO: Add bootstrapping to get NTC in center of volcano plot
```

<!-- #### Plot LFC vs logCPM -->
<!-- ```{r Exp 1.6.3. Plot log-fold change against log-counts per million, with DE genes highlighted} -->
<!-- # Define the gene of interest (its index or identifier) -->
<!-- gene_of_interest <- c("STMN2", "TARBP") -->
<!-- # TODO: why doesnt TARBP appear but not TARBP1 -->
<!-- ntc <- "negative_control" -->
<!-- # Create a status vector: highlight the gene of interest -->
<!-- status <- rep("Other", nrow(lrt$table)) # Default status for all genes -->
<!-- status[lrt$genes == gene_of_interest] <- "Gene of Interest" -->
<!-- status[lrt$genes == ntc] <- "Non-targeting Control" -->
<!-- # Plot the MD plot with the highlighted gene -->
<!-- plotMD(lrt, status = status, col = c("gray", "red"))  # 'red' will highlight the gene of interest -->
<!-- # Add horizontal lines at log fold changes of -1 and 1 (blue lines) -->
<!-- abline(h = c(-1, 1), col = "blue") -->
<!-- plotMD(lrt) -->
<!-- abline(h=c(-1, 1), col="blue") -->

##### Run Diagnostics on Volcano Plot

```{r}
plot(exp2_lrt_df$logCPM, exp2_lrt_df$logFC, xlab="Average log CPM", ylab="log-fold-change", pch=16, cex=0.4)
abline(h=0, col="red")
title(main = "MA Plot of Exp 2")

```

#### 2.x. Session Info

```{r Exp 2.x Session info}
sessionInfo()
```

<!-- ### Exp 3. Try analysis with aggregating treatment/control groups before making dge object -->

<!-- #### Reading in the data -->

<!-- ```{r} -->
<!-- exp3.mat <- clean_and_process_counts_for_dge(clean_raw_counts) -->

<!-- # Group assignment (two conditions: control and treatment) -->
<!-- group <- factor(c("Low", "Low", "Low", "High", "High", "High")) -->

<!-- # Combine technical replicates -->
<!-- # Example: Rep1_Tech1 + Rep1_Tech2, Rep2_Tech1 + Rep2_Tech2 -->
<!-- combined_counts <- cbind( -->
<!--   Low = rowSums(exp3.mat[, c("Low_rep1", "Low_rep2", "Low_rep3")]), -->
<!--   High = rowSums(exp3.mat[, c("High_rep1", "High_rep2","High_rep3")]) -->
<!-- ) -->

<!-- # Adjust group factor after combining technical replicates -->
<!-- group_combined <- factor(c("Low", "High")) -->

<!-- # Create DGEList object with combined counts -->
<!-- dge <- DGEList(counts=combined_counts, group=group_combined) -->

<!-- # Normalization (TMM) -->
<!-- dge <- calcNormFactors(dge) -->

<!-- # Estimate dispersion (biological replicates) -->
<!-- dge <- estimateDisp(dge) -->

<!-- # Perform exact test for differential expression -->
<!-- et <- exactTest(dge) -->

<!-- # View the top differentially expressed genes -->
<!-- topTags(et) -->

<!-- group <- factor(c("Low", "Low", "Low", "High", "High", "High")) -->
<!-- group <- relevel(group, ref = "Low") # Set "Low" as the reference group -->

<!-- # Create dge object -->
<!-- dge <- DGEList(counts = count_matrix, group = group) -->

<!-- # Create a new col to label replicate number and sample info  -->
<!-- dge$samples$id <- c(1,2,3,4,5,6) # 1=low1,2=low2,3=low3,4=high1,5=high2,6=high3 -->
<!-- dge$samples$replicate = factor(c("rep1", "rep2", "rep3", "rep1", "rep2", "rep3")) # high 1, low 1, high 2, low 2, high 3, low 3 -->
<!-- dge$samples$replicate <- relevel(dge$samples$replicate, ref = "rep3") -->

<!-- # Create new list to label sgRNA ID -->
<!-- dge$genes <- data.frame(gene = clean_raw_counts[, 2]) -->
<!-- # Copy the count data  -->
<!-- dge$genes <- as.data.frame(dge$genes) -->
<!-- dge$genes$sgrna_id <- as.matrix(clean_raw_counts[,1]) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- rank_test <- function(df) { -->

<!--   # Calculate the geometric mean for the high and the low samples -->
<!--   # geom_mean <- function(x) { -->
<!--   # exp(mean(log(x[x > 0]), na.rm = TRUE)) -->

<!--   # Split the dataframe into negative controls and targeting genes -->
<!--   df_ntc <- df %>% filter(grepl('negative_control', Gene)) -->
<!--   df_targeting <- df %>% filter(!grepl('negative_control', Gene)) -->

<!-- #   # Extract relevant columns from the negative control dataframe -->
<!--   ntc_sgRNA_p <- df_ntc$PValue -->
<!--   ntc_sgRNA_p_lfc <- data.frame(PValue = df_ntc$PValue, LFC = df_ntc$logFC) -->
<!-- # -->
<!-- #   # Get unique genes in the targeting dataframe -->
<!--   genes <- unique(df_targeting$gene) -->
<!--   num_of_genes <- length(genes) -->
<!-- # -->
<!-- #   # Initialize an empty list to store LFC and p-values for each gene -->
<!--   gene_lfc_p <- list() -->
<!-- # -->
<!-- #   # Loop through each gene and perform calculations -->
<!--   for (gene in genes) { -->
<!--     df_gene <- df_targeting %>% filter(Gene == gene) %>% arrange(PValue) -->

<!-- #     # Calculate the mean LFC of up to the top 3 rows -->
<!-- #     lfc <- mean(df_gene$LFC[1:min(3, nrow(df_gene))]) -->
<!-- # -->
<!-- #     # Perform the Wilcoxon rank-sum test -->
<!-- #     pvalue <- wilcox.test(df_gene$p.twosided[1:min(3, nrow(df_gene))], ntc_sgRNA_p, alternative = "two.sided")$p.value -->
<!-- # -->
<!-- #     # Store the results in the list -->
<!-- #     gene_lfc_p[[gene]] <- list(lfc = lfc, pvalue = pvalue) -->
<!-- #   } -->
<!-- # -->
<!-- #   # Set the seed for reproducibility -->
<!--   set.seed(10) -->
<!-- #   # Multiple Testing Correction - sample 5 NTCs and calculate KD phenotype scores and pvalues -->
<!--   # Perform randomization for the negative controls -->
<!--   for (j in seq_len(num_of_genes)) { -->
<!--     # Shuffle the ntc_sgRNA_p_lfc list -->
<!--     ntc_sgRNA_p_lfc <- ntc_sgRNA_p_lfc[sample(nrow(ntc_sgRNA_p_lfc)), ] -->

<!--     # Select the first 5 elements after shuffling -->
<!--     ntc_selected <- ntc_sgRNA_p_lfc[1:5, ] -->

<!--     # Extract the p-values and calculate the LFC -->
<!--     ntc_selected_p <- ntc_selected$PValue -->
<!--     ntc_lfc <- mean(ntc_selected$logFC[order(ntc_selected_p)][1:min(3, length(ntc_selected_p))]) -->

<!--     # Perform the Wilcoxon rank-sum test -->
<!--     ntc_pvalue <- wilcox.test(ntc_selected_p, ntc_sgRNA_p, alternative = "two.sided")$p.value -->
<!--     # Store the results in the list -->
<!--     gene_lfc_p[[paste0('negative_control_', j)]] <- list(lfc = ntc_lfc, pvalue = ntc_pvalue) -->
<!--   } -->
<!--   return(gene_lfc_p) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # TODO: pull out NTC and normalize both high and low groups to them, then re-run stats -->
<!-- ``` -->

# Resume here

<!-- ```{r Exp 1.4a. Assess consistency between replicate samples} -->
<!-- # Make an MDS plot to visualise relationships between replicate samples Set up infection # -->
<!-- # colors -->
<!-- # cols_rep = dge$samples$replicate -->
<!-- #  -->
<!-- # par(mfrow = c(2, 2)) -->
<!-- # plotMDS(dge, col = cols, main = "STMN2 screen: MDS Plot") -->
<!-- # legend("topleft", legend = c("Low", "High"), col = c(1, 2), pch = 15) -->
<!-- # plotMDS(x4, col = cols2, main = "Large sgRNA-seq screen: MDS Plot") -->
<!-- # legend("topleft", legend = c("Rep 1", "Rep 2", "Rep 3"), col = c(1, 2), pch = 15) -->
<!-- # ## Make an MDS plot to visualise relationships between replicate samples -->
<!-- # par(mfrow = c(1, 3)) -->
<!-- # plotMDS(dge, main = "Larger screen: MDS Plot") -->
<!-- # Begin differential representation analysis We will use GLMs in edgeR in this case since the experimental design is a time course with changes expected over time i.e. model is y -->
<!-- # = intercept + slope*time Set up design matrix for GLM -->
<!-- group <- as.factor(dge$samples$group) -->
<!-- replicate <- as.factor(dge$samples$replicate) -->
<!-- design.mat <- model.matrix(~group + replicate) -->
<!-- design.mat[1:6,] -->
<!-- # des = model.matrix(~dge$samples$group) # Uncomment to evaluate variation between FACS groups -->
<!-- # Estimate dispersions ---- -->
<!-- # Estimate common dispersion -->
<!-- xglm = estimateDisp(dge, design.mat) -->
<!-- sqrt(xglm$common.disp) -->
<!-- # Plot BCVs versus abundance ---- -->
<!-- plotBCV(xglm, main = "STMN2: BCV Plot") -->
<!-- # Fit negative binomial GLM -->
<!-- fit = glmFit(xglm, design.mat) -->
<!-- # Carry out Likelihood ratio test -->
<!-- lrt = glmLRT(fit, coef = 2) -->
<!-- # Show top ranked sgRNAs from the LRT -->
<!-- topTags(lrt) -->
<!-- # Select sgRNAs with FDR < 0.0001 and logFC <= -1 to highlight on plot -->
<!-- thresh = 1e-04 -->
<!-- lfc = 1 -->
<!-- # top10_neg = topTags(lrt, n = -Inf) -->
<!-- top10_pos = topTags(lrt, n = Inf) -->
<!-- # top10_neg_ids = top10_neg$table[top10_neg$table$FDR < thresh & top10_neg$table$logFC >= lfc, 1] -->
<!-- top10_pos_ids = top10_pos$table[top10_pos$table$FDR < thresh & top10_pos$table$logFC >= lfc, 1] -->
<!-- # TODO: Figure out how to get negative lfc changes -->
<!-- # Plot logFC versus logCPM -->
<!-- plotSmear(lrt, de.tags = top10_pos_ids, pch = 20, cex = 0.6, main = "STMN2: logFC vs logCPM") -->
<!-- abline(h = c(-1, 0, 1), col = c("dodgerblue", "yellow", "dodgerblue"), lty = 2) -->
<!-- ``` -->
<!-- ```{r Exp 1.4b Try quasi-likelihood model} -->
<!-- # Fit quasi-likelihood GLM -->
<!-- QL_fit <- glmQLFit(dge, des) -->
<!-- # Carry out quasi-likelihood ratio test -->
<!-- qlf <- glmQLFTest(QL_fit, coef = 2) -->
<!-- # Show top ranked sgRNAs -->
<!-- topTags(qlf) -->
<!-- # Select hairpins with FDR < 0.05 to highlight on plot -->
<!-- thresh = 0.005 -->
<!-- top3 = topTags(lrt, n = Inf) -->
<!-- top3ids = top3$table[top3$table$FDR < thresh, 1] -->
<!-- # Plot Slope versus logCPM -->
<!-- plotSmear(lrt, de.tags = top3ids, pch = 20, cex = 0.6, main = "Larger screen: Slope vs logCPM") -->
<!-- abline(h = c(-1, 0, 1), col = c("dodgerblue", "yellow", "dodgerblue"), lty = 2) -->
<!-- ``` -->
<!-- ```{r Exp 1.5. Summarize gene-by-gene ranking rather than sgRNA-specific ranking} -->
<!-- ``` -->
<!-- ```{r Exp 1.6. Create Volcano Plot} -->
<!-- p <- ggplot() + -->
<!--   geom_jitter(data = top10_pos, aes(x = sub_ntc_med_epsilon, y = -log10(pvalue), color = category), size = 1.5, alpha = 0.5) + ->
<!--   geom_jitter(data = df_hits %>% dplyr::filter(gene == "STMN"), aes(x = sub_ntc_med_epsilon, y = -log10(pvalue)), size = 1.5, lpha = 0.7) + -->
<!--   # Add labels for outliers using geom_label_repel -->
<!--   # geom_label_repel(data = outliers, aes(x = sub_ntc_med_epsilon, y = -log10(pvalue), label = gene),  -->
<!--   #                  size = 3, color = "black", box.padding = 0.2, point.padding = 0.2,  -->
<!--   #                  segment.color = "grey50") + -->
<!--   # geom_text(data = outliers, aes(x = sub_ntc_med_epsilon, y = -log10(pvalue), label = gene), -->
<!--   #           vjust = -0.5, hjust = -0.5, angle = 60, size = 3, color = "black") + -->
<!--   scale_color_manual(values = c("Positive hits" = "red",  -->
<!--                                 "Negative hits" = "#3C5488FF",  -->
<!--                                 "Other genes" = '#F39B7FFF',  -->
<!--                                 "Negative control" = 'grey')) + -->
<!--   labs(title = "STMN2 Screen sgRNA (FDR=0.05), thresh_25", -->
<!--        x = "Phenotype", y = "-log10 P", color = "Category") + -->
<!--   theme_linedraw() + -->
<!--   theme(legend.position = "right", legend.text = element_text(size = 10)) -->
<!-- # Add the FDR threshold lines -->
<!-- x <- seq(0.01, 10, by = 0.01) -->
<!-- y <- sapply(x, function(i) thres / i) -->
<!-- # Adding FDR lines -->
<!-- p <- p + geom_line(aes(x = x, y = y), linetype = "dashed", color = "black") + -->
<!--   geom_line(aes(x = -x, y = y), linetype = "dashed", color = "black") + -->
<!--   annotate("text", x = max(x), y = y[1], label = "FDR = 0.05", hjust = 1, size = 5) -->
<!-- # Define limits -->
<!-- lim <- max(abs(min(df$epsilon) - 1), (max(df$epsilon) + 2)) -->
<!-- p <- p + xlim(-lim, lim) + ylim(0, -log10(min(df$pvalue)) + 0.5) -->
<!-- print(p) -->
<!-- ``` -->
<!-- ### Experiment 2 - set manual filter to only retain sgRNAs with at least 0.5 counts per million in at least 3 samples and plot the overall number of reads per sample and hairpin in a barplot. Counts per million are used as these values are standardised for systematic differences in the amount of sequencing between different samples, which can be subtantial -->
<!-- ```{r} -->
<!-- # Filter hairpins with low counts -->
<!-- sel = rowSums(cpm(dge$counts) > 0.5) >= 3 -->
<!-- dge_selected = dge[sel, ] -->
<!-- # Plot number of hairpins that could be matched per sample -->
<!-- par(mfrow = c(2, 1)) -->
<!-- barplot(colSums(dge_selected$counts), las = 2, main = "Counts per index", cex.names = 0.5, cex.axis = 0.8, ylim = c(0, 2e+07)) ->
<!-- # Select hairpins from plates run in this screen -->
<!-- sample_info = dge_selected$samples$group -->
<!-- selhp = sample_info == "High" | sample_info == "Low" -->
<!-- # Plot per hairpin totals across all samples -->
<!-- barplot(rowSums(dge_selected$counts[selhp, ]), las = 2, main = "Counts per hairpin", cex.names = 0.5, -->
<!-- cex.axis = 0.8, ylim = c(0, 1500000)) -->
<!-- ``` -->
<!-- ```{r Scratch space} -->
<!-- # Was working through the code below, but thought that another tutorrial would be more helpful since it was on large screens -->
<!-- # Evaluate Variation Between Replicates - Evaluate consistency between replicate samples -------- -->
<!-- # Create a design matrix for GLM analysis -->
<!-- # Estimate and plot sgRNA variation -->
<!-- # Make an MDS plot to visualise relationships between replicate samples -->
<!-- # par(mfrow = c(1, 3)) -->
<!-- # plotMDS(dge, labels = dge$samples$group, col = rep(1:6, times = 3), main = "Another small screen: MDS Plot") -->
<!-- # legend("topright", legend = c("Low 1", "Low 2", "Low 3", "High 1", "High 2", "High 3"), col = 1:6, pch = 15) -->
<!-- # -->
<!-- # # Begin differential representation analysis We will use GLMs in edgeR in this case since -->
<!-- # # there are more than 2 groups Set up design matrix for GLM -->
<!-- # des = model.matrix(~dge$samples$group) -->
<!-- # des -->
<!-- # Subset sgRNAs and samples relevant to the "low" group -->
<!-- ``` -->
<!-- ```{r want to assert that the difference between high/low groups is similar is much the same regardless of color} -->
<!-- ``` -->
<!-- # TODO Try running edgeR on cat parsed files (combine recombinants with hits) -->
<!-- # TODO Try running edgeR on parsed recombinant files -->
<!-- # TODO: Beyond edgeR - group NTC guides as neg ctrls, thus the sgRNA totals across all samples for NTC should be significantly igher than other bars -->
<!-- # TODO: Try classic approach from edgeR - makes pairwise comparisons between groups -->
<!-- ```{r} -->
<!-- # Try the exact block above but set the sgRNA column to the gene for unique identificaiton -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # Inspect current data type -->
<!-- class(raw_counts) -->
<!-- str(raw_counts) -->
<!-- # Assuming the first column contains gene names -->
<!-- count_matrix <- as.matrix(raw_counts[, -1:-2])  # Exclude the first column if it has gene names -->
<!-- rownames(count_matrix) <- raw_counts[, 1]    # Set the gene names as rownames -->
<!-- ``` -->
<!-- ## Read alignment/processing -->
<!-- ## Count loading and annotation -->
<!-- ## Filtering and normalization -->
<!-- We next filter out sgRNAs and samples with low numbers of reads. Need a CPM greater than 5 in 15 or more samples to keep sgRNAs, nd at least 100,000 reads to keep a given sample. -->
<!-- ### Data exploration -->
<!-- ```{r volcano plot of original sgRNA file, echo=FALSE} -->
<!-- ``` -->
<!-- ### Design matrix -->
<!-- ### Dispersion estimation -->
<!-- ```{r} -->
<!-- #| echo: false -->
<!-- # Try using edgeR -->
<!-- library(edgeR) -->
<!-- library(dplyr) -->
<!-- # load data -->
<!-- raw_counts <- read.delim("/Users/Claire/Library/CloudStorage/Box-Box/MSTP Research otations/Summer_2024_Might_Ward_Lab/CRISPRi_alg_optimization/00_references_and_code/files_from_others/00_JH/01_data/00_processed_data00_mageck_counts/counts/all.count.txt", sep = "\t", header = TRUE) -->
<!-- # TODO: handle duplicate gene names -->
<!-- unique_genes_df <- raw_counts %>% -->
<!-- group_by(Gene) %>% -->
<!--   filter(n() == 1) %>% -->
<!--   ungroup() -->
<!-- rownames(unique_genes_df) <- as.character(unique_genes_df$Gene) -->
<!-- # unique_genes_df$Gene<-NULL -->
<!-- mygroups <- c("Low1","Low1","Low1","High1","High1","High1") -->
<!-- # TODO: remove zeros from sgRNA column -->
<!-- # TODO: remove zeros from Gene column -->
<!-- remove_zeros <- function(df) { -->
<!--   # Use rowSums to check for zeros or NAs in each row and keep rows without them -->
<!--   df_clean <- df[rowSums(df == 0) == 0, ] -->
<!--   return(df_clean) -->
<!-- } -->
<!-- remove_NA <- function(df) { -->
<!--   # Use rowSums to check for zeros or NAs in each row and keep rows without them -->
<!--   df_clean <- df[rowSums(is.na(df)) == 0, ] -->
<!--   return(df_clean) -->
<!-- } -->
<!-- remove_zeros_and_NA <- function(df) { -->
<!--   # Use rowSums to check for zeros or NAs in each row and keep rows without them -->
<!--   df_clean <- df[rowSums(df == 0 | is.na(df)) == 0, ] -->
<!--   return(df_clean) -->
<!-- } -->
<!-- df_no_zero <- remove_zeros(rawdata) -->
<!-- df_no_NA <- remove_NA(rawdata) -->
<!-- df_clean <- remove_zeros_and_NA(rawdata) -->
<!-- # View the total count -->
<!-- total_zero_count -->
<!-- library(edgeR) -->
<!-- y <- DGEList(counts=df_clean[,3:8], genes=df_clean[,1:2]) -->
<!-- ``` -->
<!-- # Try from the edgeR User Documentation File -->
<!-- ## Import and Sequence Processing -->
<!-- ```{r seq processing, echo=FALSE} -->
<!-- library(edgeR) -->
<!-- library(dplyr) -->
<!-- sgrna_counts <- read.delim("/Users/claireps/Desktop/dual_guide_optimization/01_sorting-based_screens/stmn2/analysis_method/magec/initial_mageck_09122024/stmn2_unpaired/results/count/all.count.txt", sep = "\t") -->
<!-- sgrna_counts[,3:8] <- lapply(sgrna_counts[,3:8], as.numeric) -->
<!-- # Specify the columns you want to convert -->
<!-- cols_to_convert <- c("Low_rep1", "Low_rep2", "Low_rep3", "High_rep1", -->
<!-- "High_rep2", "High_rep3") -->
<!-- # Convert specified columns to numeric -->
<!-- rawdata[cols_to_convert] <- lapply(rawdata[cols_to_convert], as.numeric) -->
<!-- # Loop through each numeric column and create a histogram -->
<!-- for (col in names(df)) { -->
<!--   if (is.numeric(df[[col]])) { -->
<!--     hist(df[[col]], main = paste("Histogram of", col), xlab = col, col = "skyblue") -->
<!--   } -->
<!-- } -->
<!-- ``` -->
<!-- ### Get Summary Statistics from the Counts File -->
<!-- ```{r} -->
<!-- summary.data.frame(sgrna_counts) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- counts.matrix <- lapply(sgrna_counts[,3:8], as.numeric) -->
<!-- output <- matrix(unlist(counts.matrix), ncol = 6, byrow = TRUE) -->
<!-- genes <- sgrna_counts %>% -->
<!--   dplyr::select(sgRNA, Gene) -->
<!-- genes <- base::as.data.frame(genes) -->
<!-- ``` -->
<!-- The `processAmplicons` function requires a barcode and a hairpin file. Because I don't know what a barcode file is, i will bypass this step and use the count table output from the MAGeCK algorithm. -->
<!-- ## Count loading and annotation -->
<!-- ```{r, echo=FALSE} -->
<!-- DGEList(counts = output, genes = genes) -->
<!-- ``` -->